"use strict";(self.webpackChunkbooks_summary=self.webpackChunkbooks_summary||[]).push([[11],{8453:(e,n,a)=>{a.d(n,{R:()=>s,x:()=>c});var t=a(6540);const i={},r=t.createContext(i);function s(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(r.Provider,{value:n},e.children)}},8456:(e,n,a)=>{a.r(n),a.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>h,frontMatter:()=>s,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"software-development/clean-code","title":"Clean Code - A handbook of agile software craftsmanship - Robert C. Martin","description":"General Overview","source":"@site/docs/software-development/clean-code.md","sourceDirName":"software-development","slug":"/software-development/clean-code","permalink":"/books-summary/docs/software-development/clean-code","draft":false,"unlisted":false,"editUrl":"https://github.com/razzeguimohamedzied/books-summary/tree/main/docs/software-development/clean-code.md","tags":[],"version":"current","frontMatter":{},"sidebar":"sidebar","previous":{"title":"Software Development","permalink":"/books-summary/docs/category/software-development"},"next":{"title":"Refactoring - Improving the Design of Existing Code - Martin Fowler","permalink":"/books-summary/docs/software-development/refactoring"}}');var i=a(4848),r=a(8453);const s={},c="Clean Code - A handbook of agile software craftsmanship - Robert C. Martin",l={},o=[{value:"General Overview",id:"general-overview",level:2},{value:"Chapter Summaries",id:"chapter-summaries",level:2},{value:"Chapter 1: Clean Code",id:"chapter-1-clean-code",level:3},{value:"Chapter 2: Meaningful Names",id:"chapter-2-meaningful-names",level:3},{value:"Chapter 3: Functions",id:"chapter-3-functions",level:3},{value:"Chapter 4: Comments",id:"chapter-4-comments",level:3},{value:"Chapter 5: Formatting",id:"chapter-5-formatting",level:3},{value:"Chapter 6: Objects and Data Structures",id:"chapter-6-objects-and-data-structures",level:3},{value:"Chapter 7: Error Handling",id:"chapter-7-error-handling",level:3},{value:"Chapter 8: Boundaries",id:"chapter-8-boundaries",level:3},{value:"Chapter 9: Unit Tests",id:"chapter-9-unit-tests",level:3},{value:"Chapter 10: Classes",id:"chapter-10-classes",level:3},{value:"Chapter 11: Systems",id:"chapter-11-systems",level:3},{value:"Chapter 12: Emergence",id:"chapter-12-emergence",level:3},{value:"Chapter 13: Concurrency",id:"chapter-13-concurrency",level:3},{value:"Chapter 14: Successive Refinement",id:"chapter-14-successive-refinement",level:3},{value:"Chapter 15: JUnit Internals",id:"chapter-15-junit-internals",level:3},{value:"Chapter 16: Refactoring SerialDate",id:"chapter-16-refactoring-serialdate",level:3},{value:"Chapter 17: Smells and Heuristics",id:"chapter-17-smells-and-heuristics",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",p:"p",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"clean-code---a-handbook-of-agile-software-craftsmanship---robert-c-martin",children:"Clean Code - A handbook of agile software craftsmanship - Robert C. Martin"})}),"\n",(0,i.jsx)(n.h2,{id:"general-overview",children:"General Overview"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.em,{children:"Clean Code"})," by Robert C. Martin (Uncle Bob) is a practical guide to writing readable, maintainable, and efficient software. The book emphasizes the importance of clean coding practices, arguing that writing clean code is essential for long-term software sustainability and agility. It presents principles, techniques, and real-world examples to help developers improve code quality and readability while reducing technical debt."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"chapter-summaries",children:"Chapter Summaries"}),"\n",(0,i.jsx)(n.h3,{id:"chapter-1-clean-code",children:"Chapter 1: Clean Code"}),"\n",(0,i.jsx)(n.p,{children:'Defines what "clean code" means, drawing perspectives from industry experts. Highlights key attributes such as simplicity, clarity, and minimal dependencies.'}),"\n",(0,i.jsx)(n.h3,{id:"chapter-2-meaningful-names",children:"Chapter 2: Meaningful Names"}),"\n",(0,i.jsx)(n.p,{children:"Explains how to choose meaningful, descriptive names for variables, functions, and classes to improve readability and maintainability."}),"\n",(0,i.jsx)(n.h3,{id:"chapter-3-functions",children:"Chapter 3: Functions"}),"\n",(0,i.jsx)(n.p,{children:"Advocates for small, single-purpose functions with clear names. Discusses principles like avoiding side effects and keeping function arguments minimal."}),"\n",(0,i.jsx)(n.h3,{id:"chapter-4-comments",children:"Chapter 4: Comments"}),"\n",(0,i.jsx)(n.p,{children:"Discusses when and where to use comments effectively. Argues that well-written code should minimize the need for comments by being self-explanatory."}),"\n",(0,i.jsx)(n.h3,{id:"chapter-5-formatting",children:"Chapter 5: Formatting"}),"\n",(0,i.jsx)(n.p,{children:"Covers best practices for code layout, indentation, and spacing to enhance readability and consistency."}),"\n",(0,i.jsx)(n.h3,{id:"chapter-6-objects-and-data-structures",children:"Chapter 6: Objects and Data Structures"}),"\n",(0,i.jsx)(n.p,{children:"Explores the distinction between objects (which encapsulate behavior) and data structures (which expose data) and when to use each."}),"\n",(0,i.jsx)(n.h3,{id:"chapter-7-error-handling",children:"Chapter 7: Error Handling"}),"\n",(0,i.jsx)(n.p,{children:"Promotes the use of exceptions over return codes, clear error messages, and writing error-handling code separately from business logic."}),"\n",(0,i.jsx)(n.h3,{id:"chapter-8-boundaries",children:"Chapter 8: Boundaries"}),"\n",(0,i.jsx)(n.p,{children:"Discusses handling third-party libraries and APIs, emphasizing the importance of keeping dependencies flexible and isolated."}),"\n",(0,i.jsx)(n.h3,{id:"chapter-9-unit-tests",children:"Chapter 9: Unit Tests"}),"\n",(0,i.jsx)(n.p,{children:"Stresses the importance of unit testing in writing clean code. Introduces the FIRST principles (Fast, Independent, Repeatable, Self-Validating, and Timely)."}),"\n",(0,i.jsx)(n.h3,{id:"chapter-10-classes",children:"Chapter 10: Classes"}),"\n",(0,i.jsx)(n.p,{children:"Explains how to design well-structured classes with high cohesion and low coupling. Encourages small, focused classes."}),"\n",(0,i.jsx)(n.h3,{id:"chapter-11-systems",children:"Chapter 11: Systems"}),"\n",(0,i.jsx)(n.p,{children:"Discusses designing clean systems using a layered architecture, dependency injection, and modularization."}),"\n",(0,i.jsx)(n.h3,{id:"chapter-12-emergence",children:"Chapter 12: Emergence"}),"\n",(0,i.jsx)(n.p,{children:"Outlines four rules of simple design: running tests, eliminating duplication, expressing intent, and minimizing the number of components."}),"\n",(0,i.jsx)(n.h3,{id:"chapter-13-concurrency",children:"Chapter 13: Concurrency"}),"\n",(0,i.jsx)(n.p,{children:"Explains the complexities of writing concurrent code and provides best practices for avoiding race conditions and ensuring thread safety."}),"\n",(0,i.jsx)(n.h3,{id:"chapter-14-successive-refinement",children:"Chapter 14: Successive Refinement"}),"\n",(0,i.jsx)(n.p,{children:"Demonstrates an iterative approach to improving code quality through continuous refactoring."}),"\n",(0,i.jsx)(n.h3,{id:"chapter-15-junit-internals",children:"Chapter 15: JUnit Internals"}),"\n",(0,i.jsx)(n.p,{children:"Analyzes the internals of JUnit as an example of clean code principles in a real-world project."}),"\n",(0,i.jsx)(n.h3,{id:"chapter-16-refactoring-serialdate",children:"Chapter 16: Refactoring SerialDate"}),"\n",(0,i.jsx)(n.p,{children:"Presents a detailed case study of refactoring a real Java class to improve clarity and maintainability."}),"\n",(0,i.jsx)(n.h3,{id:"chapter-17-smells-and-heuristics",children:"Chapter 17: Smells and Heuristics"}),"\n",(0,i.jsx)(n.p,{children:'Lists common "code smells" and provides heuristics for identifying and fixing bad coding practices.'}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"The book emphasizes that clean code is a discipline requiring constant practice and refinement. Writing clean code leads to software that is easier to maintain, extend, and understand, benefiting both individual developers and teams in the long run."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);